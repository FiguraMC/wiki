"use strict";(self.webpackChunkfigurawiki=self.webpackChunkfigurawiki||[]).push([[4520],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>m});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function l(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?l(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):l(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},l=Object.keys(e);for(n=0;n<l.length;n++)r=l[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)r=l[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),u=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},p=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),c=u(r),d=a,m=c["".concat(s,".").concat(d)]||c[d]||h[d]||l;return r?n.createElement(m,o(o({ref:t},p),{},{components:r})):n.createElement(m,o({ref:t},p))}));function m(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=r.length,o=new Array(l);o[0]=d;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[c]="string"==typeof e?e:a,o[1]=i;for(var u=2;u<l;u++)o[u]=r[u];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},7222:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>u});var n=r(7462),a=(r(7294),r(3905));const l={},o=void 0,i={unversionedId:"globals/Math/Math",id:"globals/Math/Math",title:"Math",description:'Contains functions which Figura adds to the default Lua "math" library table. These are accessed via the math global.',source:"@site/docs/globals/Math/Math.md",sourceDirName:"globals/Math",slug:"/globals/Math/",permalink:"/globals/Math/",draft:!1,editUrl:"https://github.com/figuramc/wiki/tree/main/docs/globals/Math/Math.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Keybind",permalink:"/globals/Keybinds/Keybind"},next:{title:"Matrices",permalink:"/globals/Matrices/"}},s={},u=[{value:"Math Functions",id:"math-functions",level:2},{value:"map",id:"map",level:3},{value:"round",id:"round",level:3},{value:"sign",id:"sign",level:3},{value:"lerpAngle",id:"lerpangle",level:3},{value:"shortAngle",id:"shortangle",level:3},{value:"clamp",id:"clamp",level:3},{value:"lerp",id:"lerp",level:3},{value:"Numbers",id:"numbers",level:2},{value:"playerScale",id:"playerscale",level:3},{value:"worldScale",id:"worldscale",level:3}],p={toc:u},c="wrapper";function h(e){let{components:t,...r}=e;return(0,a.kt)(c,(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,'Contains functions which Figura adds to the default Lua "math" library table. These are accessed via the ',(0,a.kt)("inlineCode",{parentName:"p"},"math")," global."),(0,a.kt)("h2",{id:"math-functions"},"Math Functions"),(0,a.kt)("h3",{id:"map"},"map"),(0,a.kt)("p",null,"Maps the given value from one range to another"),(0,a.kt)("p",null,"For example, if you have a value of 20 in the range 0-200, and you want to map it to the range 100-200, the result will be 110"),(0,a.kt)("h3",{id:"round"},"round"),(0,a.kt)("p",null,"Rounds the given number to the nearest whole integer"),(0,a.kt)("h3",{id:"sign"},"sign"),(0,a.kt)("p",null,"Returns the sign of the given number"),(0,a.kt)("p",null,"Returns 1 if the number is positive, -1 if it's negative, and 0 if it's 0"),(0,a.kt)("h3",{id:"lerpangle"},"lerpAngle"),(0,a.kt)("p",null,"Similar to the default lerp function, but numbers are limited to the range of 0-360"),(0,a.kt)("p",null,"Lerp is done towards the shortest angle"),(0,a.kt)("p",null,"For example, a lerp of 340 and 20, with factor of 0.75, will return 10"),(0,a.kt)("h3",{id:"shortangle"},"shortAngle"),(0,a.kt)("p",null,"Returns the shortest angle between two angles"),(0,a.kt)("p",null,"For example, if you have an angle of 350 degrees and you want to get the shortest angle between it and 0 degrees, the result will be 10 degrees"),(0,a.kt)("h3",{id:"clamp"},"clamp"),(0,a.kt)("p",null,"Clamps the given value between min and max"),(0,a.kt)("h3",{id:"lerp"},"lerp"),(0,a.kt)("p",null,"Linearly interpolates from its first argument to its second argument, with the third argument as the parameter"),(0,a.kt)("p",null,"Works on both regular numbers, vectors of the same type and matrices of the same type"),(0,a.kt)("h2",{id:"numbers"},"Numbers"),(0,a.kt)("h3",{id:"playerscale"},"playerScale"),(0,a.kt)("p",null,"The constant of the player scaling related to the world"),(0,a.kt)("h3",{id:"worldscale"},"worldScale"),(0,a.kt)("p",null,"The constant of the world scaling related with the player"))}h.isMDXComponent=!0}}]);